<title>Active Haskell Users Manual</title>
<div align="center">
<h2> Active Haskell Users Manual</h2><br>
<p><h2> John Peterson</h2><br>
<h2> Yale Haskell Project</h2><br>
</div>
<p><a name="1">
<h2>1 Introduction</h2>
Active Haskell combines 
<a href="//www.microsoft.com/intdev/avr"> Active VRML</a>, a proposed standard
by Microsoft, and Haskell.  Active Haskell is implemented as
a library of functions and types which provide most of the
functionality in Active VRML.
<p>This is an incomplete and preliminary version Active VRML.  This
implementation is not in any way an `official' implementation of
the language - it is merely a quick and dirty implementation of the
basic concepts.  Research into Active VRML ongoing and the language
will probably continue to change for some time.  There are already
significant differences between this implementation and the current
state of Active VRML - this should definitely not be taken as an
authoritative definition of Active VRML.
<p><a name="1">
<h2>1 Behaviors and Events</h2>
A <em> behavior</em> is a value which may vary over time.  
Unlike Active VRML, behaviors in Active Haskell
are explicitly tagged in the type system.  A value of type 
<tt>Behavior&nbsp;T</tt> is a time-varying value of type <tt>T</tt>.  Behaviors can be
freely mixed 
with ordinary values in a program.  Non-behavorial values appear
as constants when viewed by behaviors.  
<p>Behaviors are influenced by <em> events</em>.  An event may be either
external, such as a mouse click, or internal, a predicate over
behaviors.  Events may inject values into behaviors: the type <tt>Event&nbsp;T</tt>
designates an event which generates a value of type <tt>T</tt> when it
occurs.  Events which do not generate values have type <tt>Event&nbsp;()</tt>.
<p>An <em> event handler</em> pairs an event with a behavior to be initiated
when the event occurs.  
This makes it easier for ordinary (non-behavioral) Haskell
program components to mediate between events and behaviors.  This
decision was made for reasons of efficiency and because programming
with behaviors is often awkward.  In the real Active VRML, every value
is a behavior and this distinction is not necessary.  An event handler, 
type <tt>EventHandler&nbsp;T</tt>, generates a behavior of type <tt>T</tt> when
activated.
<p>These functions relate behaviors, events, and event handlers:
<pre><tt>
untilB :: Behavior a -&gt; EventHandler a -&gt; Behavior a
(==&gt;)  :: Event b -&gt; (b -&gt; Behavior a) -&gt; EventHandler a
(-=&gt;)  :: Event b -&gt;       Behavior a  -&gt; EventHandler a
(.|.)  :: EventHandler a -&gt; EventHandler a -&gt; EventHandler a
</tt></pre>
(This <tt>eventHandler</tt> type is not strictly necessary -- it
is used because we have restricted the value generated by an
event to be constant.  This type could be replaced by 
<tt>Event&nbsp;(Behavior&nbsp;a)</tt>, an event which returns a behavior, if a more
general implementation was used.)
The <tt>untilB</tt> function defines a behavior which becomes another
behavior when an event handler fires.  The <tt>==&gt;</tt> and <tt>-=&gt;</tt> functions
build handlers from an event and a behavior.  The signature of <tt>==&gt;</tt>
is not
<pre><tt>
(==&gt;)  :: Event b -&gt; (a -&gt; b) -&gt; b
</tt></pre>
as it would be in Active VRML.  The second argument to <tt>==&gt;</tt> is a
function which takes an ordinary value, not a behavior.  All Active
Haskell events generate constants.
<p>Here are some simple examples of behaviors:
<pre><tt>
lbp :: Event ()  -- a built-in event

b1 = 1 `untilB` lbp -=&gt; 2
b2 = 1 `untilB` lbp -=&gt; (2 `untilB` lbp -=&gt; b2)
b3 = 1 `untilB` lbp -=&gt; 2*b3
</tt></pre>
The <tt>lbp</tt> (left button press) function is a built-in event in Active
Haskell.  
<p><a name="1">
<h2>1 Using Behaviors</h2>
We say a type or function which has been moved from the domain of
ordinary Haskell values to behaviors is `lifted'.  These type synonyms
refer to some common lifted types:
<pre><tt>
type Number  = Behavior Float
type Boolean = Behavior Bool
type Point2  = Behavior (Float,Float)
type Vector2 = Behavior (Float,Float)
type Transform2 = Behavior Transform  -- 2-d point transform
type Image   = Behavior (P String)    -- P is the picture data type
type Color   = Behavior Colour        -- Used in pictures
</tt></pre>
We currently do not distinguish points from vectors.
<p>Functions which operate on behaviors must sometimes use names which
are already used by non-behavioral functions.  Some class methods can
be used for either behaviors or scalars: these have their ordinary
Haskell names.  In many instances, however, a new name must be
generated.  Two conventions are used: the suffix <tt>B</tt> of a variable
denotes a function which has been lifted to behaviors.  For operators,
the suffix <tt>*</tt> is used.  This is all somewhat confusing, since some
functions need no suffixes (like <tt>+</tt>) while others do (like <tt>&gt;</tt>).
<p>These are basic functions involving behaviors:
<pre><tt>
endB          :: Behavior a  -- terminates a behavior
time          :: Number
timeTransform :: Behavior a -&gt; Number -&gt; Behavior a
integral      :: Number -&gt; Number
derivative    :: Number -&gt; Number
</tt></pre>
All of these work as in Active VRML.  Two dimensional integrals and
derivatives are not yet available.  The integral and derivative
functions use really bad numerical methods: expect noticeable drift
from the precise behaviors.  Recursive integrals or derivatives do not
work (yet).
<p>Many basic Haskell functions have been lifted to operate on behaviors.
When possible, existing class methods have been overloaded.
<p>Functions using standard Haskell names:
<p><tt>+</tt>, <tt>-</tt>, <tt>*</tt>, <tt>abs</tt>, <tt>signum</tt>, <tt>fromInteger</tt>, <tt>/</tt>, <tt>recip</tt>,
<tt>fromRational</tt>, <tt>pi</tt>, 
<tt>exp</tt>, <tt>log</tt>, <tt>sqrt</tt>, <tt>**</tt>, <tt>sin</tt> ,<tt>cos</tt>, <tt>tan</tt>, <tt>asin</tt>, <tt>acos</tt>,
<tt>atan</tt>, <tt>sinh</tt>, <tt>cosh</tt>, 
<tt>tanh</tt>, <tt>asinh</tt>, <tt>aconh</tt>, <tt>atanh</tt>, <tt>quot</tt>, <tt>rem</tt>, <tt>div</tt>, <tt>mod</tt>,
<tt>radiansToDegrees</tt>, <tt>degreesToRadians</tt>, and <tt>log10</tt>. 
<p>Since <tt>fromInteger</tt> and <tt>fromRational</tt> work for behaviors, numeric
constants can be used directly as behaviors without lifting.
<p>These functions have been renamed:
<p><tt>==*</tt>, <tt>/=*</tt>, <tt>&lt;*</tt>, <tt>&gt;*</tt>, <tt>&lt;=*</tt>, <tt>&gt;=*</tt>, <tt>showB</tt>, <tt>toRationalB</tt>, 
<tt>toIntegerB</tt>, <tt>evenB</tt>, <tt>oddB</tt>, 
<tt>properFractionB</tt>,
<tt>truncateB</tt>, <tt>roundB</tt>,
<tt>ceilingB</tt>, and <tt>floorB</tt>.
<p>All boolean functions have been renamed: <tt>&amp;&amp;*</tt>, <tt>||*</tt>, and <tt>notB</tt>.
The constructors <tt>True</tt> and <tt>False</tt> have become <tt>true</tt> and <tt>false</tt>.
<p>Tuple constructors have been renamed <tt>t2</tt>, <tt>t3</tt>, and <tt>t4</tt>.
<p>Data structures must also be explicitly lifted into the behavorial
domain.  Points and vectors are represented by 2-tuples.  Tuple
constructors are <tt>t2</tt>, <tt>t3</tt>, and <tt>t4</tt>.  The selectors for 2-tuples (as
well as 2-dimensional points; see below) are
<tt>xComponent</tt> and <tt>yComponent</tt>; selectors for larger tuples are not
predefined.  Lifted list functions are not provided.
<p>Support functions covert non-behavorial object into behavorial
objects:
<pre><tt>
lift0      :: a -&gt; Behavior a
cB         :: a -&gt; Behavior a  -- same as lift0 (cB = constant behavior)
lift1      :: (a -&gt; b) -&gt; (Behavior a -&gt; Behavior b)
lift2      :: (a -&gt; b -&gt; c) -&gt; (Behavior a -&gt; Behavior b -&gt; Behavior c)
lift3      :: (a -&gt; b -&gt; c -&gt; d) -&gt; (Behavior a -&gt; Behavior b -&gt;
                                     Behavior c -&gt; Behavior d)
lift4      :: (a -&gt; b -&gt; c -&gt; d -&gt; e) -&gt;
              (Behavior a -&gt; Behavior b -&gt; Behavior c -&gt; Behavior d -&gt;
               Behavior e)
liftList   :: ([a] -&gt; b) -&gt; ([Behavior a] -&gt; Behavior b)
lift2NS    :: (Maybe a -&gt; Maybe b -&gt; Maybe c) -&gt;
              (Behavior a -&gt; Behavior b -&gt; Behavior c)
</tt></pre>
The <tt>lift2NS</tt> functions is special: it is non-strict in that it does
not necessarily end when one of its arguments ends (this is an
experimental addition to active Haskell and does not directly correspond to
any AVRML construct).  An <tt>end</tt> is represented by <tt>Nothing</tt> in this
function.  There are no corresponding functions to push behaviors back
to ordinary Haskell values.  Since behaviors are time varying, this is
not sensible.  However, the <tt>snapshot</tt> function pushes a
behavorial value (sampled at a specific instant) back to the Haskell
world.
<p><a name="1">
<h2>1 Events</h2>
These operations deal with events:
<pre><tt>
predicate   :: Behavior Bool -&gt; Event ()
(.|.)       :: Event a -&gt; Event a -&gt; Event a 
suchThat    :: Event a -&gt; (a -&gt; Bool) -&gt; Event a
snapshot    :: Behavior a -&gt; Event () -&gt; Event a
doneB       :: Behavior a -&gt; Event ()
doneE       :: Event ()
bothE       :: Event a -&gt; Event b -&gt; Event (a,b)
(.&amp;.)       :: Event a -&gt; Event b -&gt; Event b

lbp         :: Event ()    -- left button press
rbp         :: Event ()    -- right button press
doubleClick :: Event ()
mouseOver   :: String -&gt; Event ()  -- Refers to a named object
clickOn     :: String -&gt; Event ()  -- mouseOver + lbp

randomE     :: Event [Float]  -- range is [0,1]
</tt></pre>
Note that the filtering function used by <tt>suchThat</tt> does not take a
behavior.  The <tt>.|.</tt> is actually overloaded to work for both events
and event handlers.
<p>A few of these functions are not part of Active VRML: <tt>doneE</tt>
corresponds do <tt>done</tt> in AVRML.  It fires when the behavior on the
left side of <tt>until</tt> is done.  The <tt>doneB</tt> event takes an explicit
behavior.
<p>The treatment of `andEvent' is also slightly different.  The <tt>bothE</tt>
function corresponds to AVRML andEvent.  The <tt>.&amp;.</tt> event ignores
the result returned by the first event.
<p>The <tt>randomE</tt> event in used to generate a list of random numbers;
floats between 0 and 1.  This functions as the AVRML event
<tt>snapshot(seededRandom&nbsp;&lt;seed&gt;,predicate(true))</tt> except a list of
randoms is created.
<p>Two infix operators simplify event expressions:
<pre><tt>
(##) :: Event a -&gt; Behavior b -&gt; Event b
e ## b = b `snapshot` e
(#&gt;) :: Boolean -&gt; Behavior b -&gt; Event b
p #&gt; b = predicate p ## b
</tt></pre>
<p><a name="1">
<h2>1 Images, Points, and Vectors</h2>
The current imaging operations in Active Haskell do not exactly
correspond to AVRML imaging.  All of
these imaging functions operate on behaviors.  The suffix <tt>I</tt> is used
to denote behavioral imaging functions.
<p>These functions operate on 2 dimensional points and vectors:
<pre><tt>
point2Xy         :: Number -&gt; Number -&gt; Point2  -- same as `t2'
xComponent       :: Point2 -&gt; Number
yComponent       :: Point2 -&gt; Number
origin2          :: Point2
add2             :: Point2 -&gt; Point2 -&gt; Point2
sub2             :: Point2 -&gt; Point2 -&gt; Point2
distance2        :: Point2 -&gt; Point2 -&gt; Number
distanceSquared2 :: Point2 -&gt; Point2 -&gt; Number
transformPoint2  :: Transform2 -&gt; (Point2 -&gt; Point2)

xVector2         :: Vector2
yVector2         :: Vector2
vector2Xy        :: Number -&gt; Number -&gt; Vector2
normal2          :: Vector2 -&gt; Vector2
length2          :: Vector2 -&gt; Number
lengthSquared2   :: Vector2 -&gt; Number
scaleV2          :: Vector2 -&gt; Number -&gt; Vector2
dot              :: Vector2 -&gt; Vector2 -&gt; Number
</tt></pre>
<p>Transformations on 2-D points:
<pre><tt>
combine2         :: Transform2 -&gt; Transform2 -&gt; Transform2
identity2        :: Transform2
translate2       :: Point2                   -&gt; Transform2
scale2           :: Number     -&gt; Number     -&gt; Transform2
rotate2          :: Number                   -&gt; Transform2
</tt></pre>
<p>Built-in colors:
<pre><tt>
white            :: Color
black            :: Color
red              :: Color
green            :: Color
blue             :: Color
lightBlue        :: Color
royalBlue        :: Color
yellow           :: Color
brown            :: Color
gray             :: Number -&gt; Color -- 0.0 = black; 1.0 = white
rgb              :: Number -&gt; Number -&gt; Number -&gt; Color -- 0 &lt;= args &lt;= 1
interpolateColor :: Color -&gt; Color -&gt; Number -&gt; Color
</tt></pre>
The <tt>interpolate</tt> function interpolates between colors - the number
should be between 0 and 1.
<p>These functions deal with images.  Unlike AVRML, images have an
implicit bounding box which governs the spatial relation between
images in operators such as <tt>besideI</tt>. 
<pre><tt>
empty          :: Image
over           :: Image -&gt; Image -&gt; Image
above          :: Image -&gt; Image -&gt; Image
beside         :: Image -&gt; Image -&gt; Image

aboveSpace     :: Number -&gt; Image -&gt; Image -&gt; Image 
besideSpace    :: Number -&gt; Image -&gt; Image -&gt; Image

overProp       :: Boolean -&gt; Number -&gt; Image -&gt; Image -&gt; Image
overFixed      :: Boolean -&gt; Number -&gt; Image -&gt; Image -&gt; Image

-- "scaledToI w h i" scales "i" to fit inside a rectangle of size "(w,h)".
scaledTo       :: Number -&gt; Number -&gt; Image -&gt; Image

move           :: Number -&gt; Number -&gt; Image -&gt; Image
centre         ::                     Image -&gt; Image

transform      :: Transform2       -&gt; Image -&gt; Image
translate      :: Point2           -&gt; Image -&gt; Image
rotate         :: Number           -&gt; Image -&gt; Image
scale          :: Number -&gt; Number -&gt; Image -&gt; Image
	     
color          :: Color            -&gt; Image -&gt; Image
invisible      ::                     Image -&gt; Image
inBox          ::                     Image -&gt; Image

square         :: Number    -&gt; Image
circle         :: Number    -&gt; Image
	     
regular        :: Behavior Int -&gt; Number -&gt; Image  -- regular polygon
	     
rect           :: Vector2   -&gt; Image
ellipse        :: Vector2   -&gt; Image
	     
line           :: Point2 -&gt; Point2 -&gt; Image
poly           :: [Point2]         -&gt; Image
importBitmap   :: String -&gt; Image  -- string names a .bmp file

label          :: String -&gt; Image -&gt; Image  -- Used by `clickOn' events
</tt></pre>
The functions <tt>overPropI</tt> and <tt>overFixedI</tt> are variations on <tt>overI</tt>
which scales one of the images relative to the other image.  For
<tt>overPropI</tt>, the size of the scaled image is a proportion of the size
of the other image. For <tt>overFixedI</tt>, the size of the scaled image is
a fixed amount larger (or smaller) than the other image.
Which image is scaled is determined by a Boolean.  For example,
<tt>overScaled&nbsp;True&nbsp;&nbsp;0.5&nbsp;i1&nbsp;i2</tt> creates an image consisting of 
<tt>i1</tt> (unchanged) and <tt>i2</tt> scaled to be half the size of <tt>i1</tt>.
<tt>overFixed&nbsp;&nbsp;False&nbsp;10&nbsp;&nbsp;i1&nbsp;i2</tt> creates an image consisting of
<tt>i1</tt> scaled to be 10 units smaller than <tt>i2</tt>; <tt>i2</tt> is unchanged.
<p>The <tt>moveI&nbsp;x&nbsp;y&nbsp;i</tt> function moves the bounding box of image <i>i</i> so that
the left <tt>x</tt> of <tt>i</tt> is left of the origin; and the bottom <tt>y</tt> of <tt>i</tt>
is below the origin.  For example, <tt>moveI&nbsp;0.5&nbsp;0.5&nbsp;i</tt> centers <tt>i</tt> while 
<tt>moveI&nbsp;0.0&nbsp;0.5&nbsp;i</tt> moves the image so that its <i>west</i> side is on the origin. 
<p>The <tt>labelI</tt> function is used to create <i>pickable</i> objects.
<p><a name="1">
<h2>1 Examples</h2>
Here are the examples found in the AVRML documentation, translated to
active Haskell.
<p>Functions can be treated in two different ways.  If all operations
used in the function are available as behavorial functions, the
function can be written directly.  However, if operations which are
not available at the behavioral level are used, the entire function 
can be written in traditional Haskell and then lifted.  For example,
the <tt>swizzle</tt> function, could be written as:
<pre><tt>
swizzle' :: Integer -&gt; Integer
swizzle' seed = if seed == 1 then
                       1
                else if odd seed then
                  swizzle (3*seed+1)
                else
                  swizzle (seed `div` 2 + 3)

swizzle :: Behavior Integer -&gt; Behavior Integer
swizzle = lift1 swizzle'
</tt></pre>
This allows the function to be written in `full Haskell' but with an
explicit lifting required.  There are a number of advantages to using
`real' Haskell: some constructs, such as numeric patterns, cannot be
used behaviorally.  More seriously, some conditionals work properly at
the Haskell level but not as behaviors.  This is due to a problem with
the present implementation being too strict and evaluating both
alternatives of a conditional.  This problem is not inherent in Active
VRML; it is simple a limitation of this particlar implementation.
This same function could be written as
<pre><tt>
swizzle seed = if' (seed ==* 1)
                       1
                    (if' (odd seed)
                       (swizzle (3*seed+1))
                       (swizzle (seed `div` 2 + 3)))
  where if' a b c = lift3 (if a then b else c)
</tt></pre>
The problem is that <tt>if</tt> has not been lifted to behaviors so it must
be lifted explicitly.  Due to the recursion in <tt>swizzle</tt>, this does
not even work in the present system.
<p>Some of the smaller examples:
<pre><tt>
redC `untilB` lbp -=&gt; yellowC .|.
              rbp -=&gt; greenC

cyclic = redC `untilB` lbp -=&gt;
              (greenC `untilB` lbp -&gt; cyclic)
</tt></pre>
<p>Finally, a `bouncing ball':
<pre><tt>
main = runI (bounceFrom 0.5 0 `untilB` lbp -=&gt; endB)

ball :: Point2 -&gt; Image
ball p = translateI p $
         colorI redC  $
         circleI 0.05

gravity :: Number
gravity = -0.1

bounceFrom :: Float -&gt; Float -&gt; Image
bounceFrom y dy = ball p `untilB`
                           snapshot (t2 y' dy')
                                    (predicate (dy' &lt;* 0 ||* y' &lt;* 0.05)) ==&gt;
                           \(y,dy) -&gt; bounceFrom y ((-dy) * 0.9)
  where
     p = t2 0.5 y'
     y' = cB y + integral dy'
     dy' = cB dy + integral gravity
</tt></pre>
In this example, <tt>runI</tt> is the top level driver.  It displays the
animation in a unit square until the displayed behavior ends.  At the
top level, a left button press exits the program.
<p>The <tt>bounceFrom</tt> function mixes non-behavioral and behavioral values.
Since <tt>y</tt> and <tt>dy</tt> are constants within this behavior, they need not
be lifted except where referenced in behavioral expressions (using
<tt>cB</tt>, which creates a constant behavior).  The <tt>snapshot</tt> event is
crucial in that it allows the position and velocity at then end of one
bounce to determine the initial position and velocity for the next
one. 
  
Many other demos are provided in the demos directory.
<p><a name="1">
<h2>1 Debugging</h2>
Two functions allow behaviors and events to be traced as the Active
Haskell program executes:
<pre><tt>
traceB     :: String -&gt; Behavior a -&gt; Behavior a
traceE     :: String -&gt; Event a -&gt; Event a
</tt></pre>
The string argument is used to identify the output associated with the
behavior or event.
<p><a name="1">
<h2>1 Implementation Techniques</h2>
The basic implementation strategy is built around two concepts:
initiation and update.  These techniques are uniform across both
behaviors and events, so only behaviors will be described here.
<p>Initiation takes a behavior and returns a snapshot of a running
behavior.  A snapshot is a pair consisting of the current value of the
behavior and a continuation which will produce the next value.  The
type <tt>State</tt> holds the current system state.
<pre><tt>
data State = &lt;internal state&gt;
data Behavior a = ...
data RunningB a = ...
type SS a = (Maybe a, RunningB a)  -- Snapshot
initiateB :: State -&gt; Behavior a -&gt; SS a
updateB :: State -&gt; RunningB a -&gt; SS a
</tt></pre>
The <tt>Maybe</tt> type in the snapshot is used to denote behavior
termination.  The <tt>State</tt> includes the current time and the set of
external events which have occurred since the last time slot.
<p>The basic driver for the program is as follows:
<pre><tt>
runI :: Image -&gt; IO ()
runI b =
  let loop (value,nextB) =
    case value of 
      Nothing -&gt; return ()
      Just image -&gt; do displayImage image
                       e &lt;- getEvents
                       t &lt;- getCurrentTime
                       b' &lt;- updateB (makeState e t) nextB
                      loop b'
  in
    b' &lt;- initiateB empty b
    loop b'
</tt></pre>
Internally, the continuation functions have all been placed in the IO
monad.  This allows behaviors and events to perform IO (as with the
tracing functions) and generally interact with the global state.
<p><a name="1">
<h2>1 Performance Issues</h2>
There are a number of problems with this implementation that can lead
to serious performance problems:
<ul>
<li> Events are constantly polled.  That is, in <tt>b1&nbsp;`untilB`&nbsp;e&nbsp;==&gt;&nbsp;b2</tt>
the event <tt>e</tt> is re-evaluated at each time step.  In some cases, such
as <tt>predicate</tt>, this is necessary.  It is expected the compilation
techniques such as interval analysis will be able to eliminate
polling, even when predicate is used.
<p><li> Since Haskell is a pure language, at each clock tick the
definitions of the active behaviors are rebuilt.  This leads to lots
of consing at runtime.  A better implementation would update behaviors
in place.
</ul>
<p><a name="1">
<h2>1 Semantic Issues</h2>
There a number of unresolved semantic issues and divergences between
the present implementation and an ideal implementation of Active
Haskell:
<ul>
<li> Active Haskell uses sampling: precise predicates must be
avoided.  Instead of a predicate such as <tt>time&nbsp;==*&nbsp;1</tt>, use
<tt>time&nbsp;&gt;=*&nbsp;1</tt> since it is unlikely to be sampled exactly at time 1.
<li> Another anomaly of discreet sampling is that a behavior may
terminate for a single sample.  For example, in
<pre><tt>
repeat b = b `untilB` doneE -=&gt; b
</tt></pre>
when <tt>b</tt> ends, the <tt>untilB</tt> will return <tt>end</tt> for one tick before the
<tt>doneE</tt> resumes the behavior.  In general, the handlers in an <tt>untilB</tt>
keep watching for events even after the initial behavior terminates.
Thus, a behavior may terminate and then restart.
<li> The effects of behavior termination within events are not well
specified in AVRML.  We have made the following choices:
<ul>
<li> If the behavior in a <tt>predicate</tt> event terminates, it is the
same as the predicate being false.
<li> If the behavior in a <tt>snapshot</tt> terminates, the snapshot event
will not occur.
</ul>
<li> The implementation of <tt>derivative</tt> produces an initial 0 until
the underlying behavior is sampled again.
</ul>
<p>